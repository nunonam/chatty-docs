{"pageProps":{"frontmatter":{},"headings":[{"depth":2,"value":"1. Two way of starting Chat"},{"depth":3,"value":"Start with member id"},{"depth":3,"value":"Start at chat id"},{"depth":2,"value":"2. How to connect to chat socket."},{"depth":3,"value":"Chat connect payload"},{"depth":2,"value":"3. How to fetch messages"},{"depth":3,"value":"fetchMessages payloads"},{"depth":2,"value":"4. Chat socket handlers"},{"depth":3,"value":"1). onChatConnect"},{"depth":3,"value":"2). onMessagesFetch"},{"depth":3,"value":"3). onMessageReceive"},{"depth":3,"value":"4). onMessagesUpdate"},{"depth":3,"value":"5). onMessageSend"},{"depth":3,"value":"6). onChatRefresh"},{"depth":2,"value":"5. Send text or file message"}],"body":{"compiledSource":"var d=Object.defineProperty,g=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var i=(e,t,a)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,s=(e,t)=>{for(var a in t||(t={}))r.call(t,a)&&i(e,a,t[a]);if(o)for(var a of o(t))c.call(t,a)&&i(e,a,t[a]);return e},h=(e,t)=>g(e,l(t));var p=(e,t)=>{var a={};for(var n in e)r.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&o)for(var n of o(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a};const makeShortcode=e=>function(a){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",s({},a))},InfoBlock=makeShortcode(\"InfoBlock\"),NextBlock=makeShortcode(\"NextBlock\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,t=p(n,[\"components\"]);return mdx(MDXLayout,h(s(s({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h1\",null,\"Starting Chat\"),mdx(\"h2\",null,\"1. Two way of starting Chat\"),mdx(\"h3\",null,\"Start with member id\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Used when starting chat by selecting peer member id (in case of not being aware of chat id)\"),mdx(\"li\",{parentName:\"ul\"},`Let's assume that user want to chat by touching chat button at other user's profile screen. If the other user also registered as a chat member through init method, Chating with the user is an available.\nPressing the chat button and navigating to chat screen with 'with' param that indicates member id is the begining of starting a chat.`)),mdx(\"h3\",null,\"Start at chat id\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Used when starting chat by selecting a chat at chatlist\"),mdx(\"li\",{parentName:\"ul\"},\"Pressing a chat of the chatlist and navigating to a chat screen with 'at' param that indicates chat id is the begining of starting a chat.\")),mdx(\"h2\",null,\"2. How to connect to chat socket.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Should use an instance of ChattyChat class to connect to chat socket\"),mdx(\"li\",{parentName:\"ul\"},\"When create ChattyChat instance, specify 6 chat handlers.\"),mdx(\"li\",{parentName:\"ul\"},\"chattyList of ChattyChat constructor is an optional parameter and an instance of ChattyList class. In case of navigating from ChatList, use the instance of chatlist then it will help to update the chat of chatlist without writing code\")),mdx(\"h3\",null,\"Chat connect payload\"),mdx(\"p\",null,\"Below code is a part of Types.d.ts \"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Types.d.ts\n\nexport interface ChatConnectPayloadType {\n  /**\n   * Required in case of navigating from ChatList\n   * It should be a chat id\n   */\n  at?: string;\n\n  /**\n   * Required in case of starting chat by selecting member id not chat id\n   * It shoud be an array of member ids\n   */\n  with?: Array<string>;\n\n  /**\n   * This key makes the chat unique\n   * When trying to connect with a same distinctKey. always same chat is connected.\n   * Whereas, if connect without distinctKey, always new chat is created.\n   * Create your own custom key or use generateDistinctKey, static method of Chatty class which returns md5 hashed value. \n   * If using generateDistinctKey method, use member ids as parameters\n   */\n  distinctKey?: string;\n\n  /**\n   * Group name for grouping(filtering) chat at chatlist\n   * Used only when creating a new chat\n   */\n  group?: string;\n\n  /**\n   * Chat name\n   * Used only when creating a new chat\n   */\n  name?: string;\n\n  /**\n   * Image url for chat image\n   * Used only when creating a new chat\n   */\n  image?: string;\n\n  /**\n   * If it's true, the chat is opened to every member at chatlist\n   * default is false (private)\n   */\n  public?: boolean;\n\n  /**\n   * Extra custom information for chat\n   * Size can't exceed 2K\n   * Used only when creating a new chat\n   */\n  data?: any;\n}\n`)),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\nimport * as React from 'react';\nimport { View } from 'react-native';\nimport Chatty, { ChattyChat, ChattyTypes } from 'chatty-client';\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState(); // state for ChattyChat instance that used in this screen\n\n  ...\n\n  React.useEffect(() => {\n    const chattychat = new ChattyChat({\n      chattyList: props.chattylist,       // Instance of ChattyList. It will help to update this chat of chatlist (In case of navigating from ChatList)\n      onChatConnect: onChatConnect,       // refer to below handlers section\n      onMessagesFetch: onMessagesFetch,   // refer to below handlers section\n      onMessageReceive: onMessageReceive, // refer to below handlers section\n      onMessagesUpdate: onMessagesUpdate, // refer to below handlers section\n      onMessageSend: onMessageSend,       // refer to below handlers section\n      onChatRefresh: onChatRefresh,       // refer to below handlers section\n    });\n\n    chattychat.connect({\n      at: props.at,\n      with: props.with,\n      distinctKey: props.distinctKey,\n      group: props.group,\n      name: props.name,\n      image: props.image,\n      data: props.data\n    });\n\n    setChatty(chattychat);\n    \n    // When unmount, disconnect chatlist socket\n    return () => {\n      Chatty.getMissedCount();\n      chattychat.disconnect();\n    }\n  }, []);\n\n  return (\n    <View>\n    /* Render UI Component */\n    </View>\n  );\n\n}\n\n\n`)),mdx(InfoBlock,{type:\"note\",mdxType:\"InfoBlock\"},\"- Chat Members can join until maximum 100\"),mdx(\"h2\",null,\"3. How to fetch messages\"),mdx(\"p\",null,\"When chat is connected successfuly, call chatty.fetchMessages()\"),mdx(\"h3\",null,\"fetchMessages payloads\"),mdx(\"p\",null,\"Below code is a part of Types.d.ts\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`export interface FetchMessagesPayloadType {\n  /**\n   * if it's true, fetch messages as refresh. (page === 1)\n   * if it's false, fetch messages as loadmore. (page > 1)\n   */\n  refresh?: boolean;\n}\n`)),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n\n  React.useEffect(() => {\n    if (chatty && connected) {\n      chatty?.fetchMessages({refresh: true});\n    }\n  }, [connected, chatty]);\n\n  ...\n}\n`)),mdx(\"h2\",null,\"4. Chat socket handlers\"),mdx(\"h3\",null,\"1). onChatConnect\"),mdx(\"p\",null,\"This is called when chat socket is connected successfuly.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n\n  ...\n\n  const onChatConnect = (data: ChattyTypes.ChatConnectResponseType) => {\n    if (data.error) {\n      console.warn('onChatConnect error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      id: string,     // (uuid type)\n      image: string,  // (url type)\n      name: string,\n      public: boolean,\n      distinctKey: string,\n      group: string,\n      data: any,\n      lastMessage: {\n        text: string, \n        files: string[], \n        type: 'TEXT' | 'FILE' | 'JSON', \n        by: 'USER' | 'ADMIN', \n        createdAt: Date,\n        translation: {\n          [key: string]: string\n        }\n      },\n      updatedAt: Date,\n      Members: [\n        id: string,\n        name: string,\n        avatar: string,   // (url type)\n        group: string,\n        data: any,\n        language: string, // (ex: \"en\")\n        country: string,  // (ex: \"US\")\n        missedCount: number,\n        permission: \"WRITE\" | \"READ\",\n        role: \"MEMBER\" | \"ADMIN\"\n      ]\n    }\n    */\n\n    setChat(data);\n    setConnected(true);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"2). onMessagesFetch\"),mdx(\"p\",null,\"Callback function called after fetching messages\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessagesFetch = (data: ChattyTypes.MessagesFetchResponseType) => {\n    if (data.error) {\n      console.warn('onMessagesFetch error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      hasNext: true,\n      refresh: true,\n      messages: [\n        id: string,\n        text: string,\n        files: string[] | null,\n        json: any\n        type: 'TEXT' | 'FILE' | 'JSON', \n        by: 'USER' | 'ADMIN', \n        createdAt: Date,\n        readReceipt: number,\n        translation: {\n          [key: string]: string\n        },\n        Sender: {\n          id: string, \n          name: string, \n          avatar: string, \n          group: string, \n          data: any\n        }\n      ]\n    }\n    */\n    if (data.refresh) {\n      const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n      setMessages(messagesMap);\n    } else {\n      setMessages((oldMessages) => {\n        const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n      });\n    }\n\n    setHasNext(data.hasNext);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"3). onMessageReceive\"),mdx(\"p\",null,\"Callback function called when receive new message.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  /**\n    * Response data type.\n  data: {\n    id: string,\n    text: string,\n    files: string[] | null,\n    json: any\n    type: 'TEXT' | 'FILE' | 'JSON', \n    by: 'USER' | 'ADMIN', \n    createdAt: Date,\n    readReceipt: number,\n    translation: {\n      [key: string]: string\n    },\n    Sender: {\n      id: string, \n      name: string, \n      avatar: string, \n      group: string, \n      data: any\n    }\n  }\n  */\n  const onMessageReceive = (data: ChattyTypes.MessageReceiveResponseType) => {\n    if (data.error) {\n      console.warn('onMessageReceive error', data.error.message);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[data['id'], data]]);\n      return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"4). onMessagesUpdate\"),mdx(\"p\",null,\"Callback function called when messages are updated. mainly used when readReceipt updated.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessagesUpdate = (data: ChattyTypes.MessagesUpdateResponseType) => {\n    if (data.error) {\n      console.warn('onMessagesUpdate error', data.error.message);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messagesMap = new Map(data.map((e) => [e['id'], e]));\n      return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"5). onMessageSend\"),mdx(\"p\",null,\"Callback function called after message is sent\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessageSend = (data: ChattyTypes.MessageSendResponseType) => {\n    if (data.error) {\n      console.warn('onMessageSend error', data.error.message);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[data['id'], data]]);\n      return new Map([...Array.from(oldMessages), ...Array.from(messageMap)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"6). onChatRefresh\"),mdx(\"p\",null,\"Callback function called when chat is refreshed. mainly called when chat member changed\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onChatRefresh = (data: ChattyTypes.ChatRefreshResponseType) => {\n    if (data.error) {\n      console.warn('onChatUpdate error', data.error.message);\n      return;\n    }\n  \n    setChat(data);\n  }\n\n  ...\n\n}\n`)),mdx(\"h2\",null,\"5. Send text or file message\"),mdx(\"p\",null,`The result of sending message can be confirmed in onMessageSend handlers.\nsendTextMessage and sendFileMessage methods returns a temporary message syncronously.`),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [connected, setConnected] = React.useState(false);\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const sendTextMessage = (message: string) => {\n    const newMessage = chatty?.sendTextMessage(message);\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendTextMessage fail');\n    }\n  }\n\n  const sendFileMessage = (message: Array<ChattyTypes.FileType>) => {\n    const newMessage = chatty?.sendFileMessage(message);\n\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendFileMessage fail');\n    }\n  }\n\n  ...\n\n}\n`)),mdx(NextBlock,{steps:[{text:\"Listing Chats\",link:\"/getting-started/listing-chats\"}],mdxType:\"NextBlock\"}))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"getting-started/starting-chat","lastUpdatedOn":"2022-08-27T12:05:39+09:00"}},"__N_SSG":true}