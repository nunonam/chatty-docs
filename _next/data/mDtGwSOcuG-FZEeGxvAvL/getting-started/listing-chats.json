{"pageProps":{"frontmatter":{},"headings":[{"depth":2,"value":"1. How to connect to chatlist socket."},{"depth":2,"value":"2. How to fetch chatlist"},{"depth":3,"value":"fetchChatList payloads"},{"depth":2,"value":"3. ChatList socket handlers"},{"depth":3,"value":"1). onChatListConnect"},{"depth":3,"value":"2). onChatListFetch"},{"depth":3,"value":"3). onChatListUpdate"},{"depth":3,"value":"In cases of updating a specific chat of ChatList"}],"body":{"compiledSource":"var d=Object.defineProperty,l=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var i=(t,e,a)=>e in t?d(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,o=(t,e)=>{for(var a in e||(e={}))r.call(e,a)&&i(t,a,e[a]);if(n)for(var a of n(e))c.call(e,a)&&i(t,a,e[a]);return t},h=(t,e)=>l(t,C(e));var p=(t,e)=>{var a={};for(var s in t)r.call(t,s)&&e.indexOf(s)<0&&(a[s]=t[s]);if(t!=null&&n)for(var s of n(t))e.indexOf(s)<0&&c.call(t,s)&&(a[s]=t[s]);return a};const makeShortcode=t=>function(a){return console.warn(\"Component \"+t+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",o({},a))},NextBlock=makeShortcode(\"NextBlock\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var s=a,{components:t}=s,e=p(s,[\"components\"]);return mdx(MDXLayout,h(o(o({},layoutProps),e),{components:t,mdxType:\"MDXLayout\"}),mdx(\"h1\",null,\"Listing Chats\"),mdx(\"h2\",null,\"1. How to connect to chatlist socket.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Should u an instance of ChattyList class to connect to chatlist socket\"),mdx(\"li\",{parentName:\"ul\"},\"When create ChattyList instance, specify 3 chatlist handlers.\")),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\nimport * as React from 'react';\nimport { View } from 'react-native';\nimport { ChattyList, ChattyTypes } from 'chatty-client';\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState(); // state for ChattyList instance that used in this screen\n  \n  ...\n\n  /**\n   * Create ChatList instance And connect\n   */\n  React.useEffect(() => {\n    const chattylist = new ChattyList({\n      onChatListConnect: onChatListConnect, // refer to below handlers section\n      onChatListFetch: onChatListFetch,     // refer to below handlers section\n      onChatListUpdate: onChatListUpdate    // refer to below handlers section\n    });\n\n    chattylist.connect();\n\n    setChatty(chattylist);\n\n    // When unmount, disconnect chatlist socket\n    return () => {\n      chattylist.disconnect();\n    }\n  }, []);\n\n  return (\n    <View>\n    /* Render UI Component */\n    </View>\n  );\n}\n\n`)),mdx(\"h2\",null,\"2. How to fetch chatlist\"),mdx(\"p\",null,\"When chatlist is connected successfuly, call chatty.fetchChatList()\"),mdx(\"h3\",null,\"fetchChatList payloads\"),mdx(\"p\",null,\"Below code is a part of Types.d.ts\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`Types.d.ts\n\nexport interface FetchChatListPayloadType {\n  /**\n   * if it's true, fetch chatlist as refresh. (page === 1)\n   * if it's false, fetch chatlist as loadmore. (page > 1)\n   */\n  refresh?: boolean;\n\n  /**\n   * When need to be filtered by group name, specify it here\n   */\n  group?: string;\n}\n\n`)),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  const [connected, setConnected] = React.useState(false);\n\n  ...\n\n  React.useEffect(() => {\n    if (chatty && connected) {\n      chatty.fetchChatList({ refresh: true, group: props.group });\n    }\n  }, [connected, chatty]);\n\n  ...\n\n}\n`)),mdx(\"h2\",null,\"3. ChatList socket handlers\"),mdx(\"h3\",null,\"1). onChatListConnect\"),mdx(\"p\",null,\"This is called when chatlist socket is connected successfuly.\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  const [connected, setConnected] = React.useState(false);\n\n  ...\n\n  const onChatListConnect = (data: ChattyTypes.ChatListConnectResponseType) => {\n    if (data.error) {\n      console.warn('onChatListConnect error', data.error.message);\n      return;\n    }\n\n    setConnected(true);\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"2). onChatListFetch\"),mdx(\"p\",null,\"This is called when fetchChatList is success\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  const [connected, setConnected] = React.useState(false);\n  const [hasNext, setHasNext] = React.useState(true);\n\n  ...\n\n  const onChatListFetch = (data: ChattyTypes.ChatListFetchResponseType) => {\n    if (data.error) {\n      console.warn('onChatListFetch error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      chats: [\n        id: string,     // (uuid type)\n        image: string,  // (url type)\n        name: string,\n        public: boolean,\n        distinctKey: string,\n        group: string,\n        data: any,\n        lastMessage: {\n          text: string, \n          files: string[] | null, \n          type: 'TEXT' | 'FILE' | 'JSON', \n          by: 'USER' | 'ADMIN', \n          createdAt: Date,\n          translation: {\n            [key: string]: string\n          }\n        },\n        updatedAt: Date,\n        Members: [\n          id: string,\n          name: string,\n          avatar: string,   // (url type)\n          group: string,\n          data: any,\n          language: string, // (ex: \"en\")\n          country: string,  // (ex: \"US\")\n          missedCount: number,\n          permission: \"WRITE\" | \"READ\",\n          role: \"MEMBER\" | \"ADMIN\"\n        ]\n      ],\n      hasNext: false,\n      refresh: true\n    }\n    */\n\n    \n    if (data.refresh) {\n      const messagesMap = new Map(data.chats.map((e) => [e['id'], e]));\n      setChatList(messagesMap);\n    } else {\n      setChatList((oldChats) => {\n        const chatsMap = new Map(data.chats.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldChats), ...Array.from(chatsMap)]);\n      });\n    }\n\n    setHasNext(data.hasNext);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"3). onChatListUpdate\"),mdx(\"p\",null,\"This is called when need to update a specific chat of ChatList in case of navigating to Chat screen through ChatList.\"),mdx(\"h3\",null,\"In cases of updating a specific chat of ChatList\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"when lastMessage updated\"),mdx(\"li\",{parentName:\"ul\"},\"when unread messages are marked as read\")),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n\n  ...\n\n  const onChatListUpdate = (data: ChattyTypes.ChatListUpdateResponseType) => {\n    if (data.error) {\n      console.warn('onChatListRefresh error', data.error.message);\n      return;\n    }\n\n    setChatList((oldChats) => {\n      const chatMap = new Map([[data['id'], data]]);\n\n      // When lastMessage was updated, this chat should go to top of the list\n      // Delete and add to ahead of the array\n      if (data.updatedAt !== oldChats.get(data['id'])?.updatedAt) {\n        oldChats.delete(data['id']);\n        return new Map([...Array.from(chatMap), ...Array.from(oldChats)]);\n      } else {\n        return new Map([...Array.from(oldChats), ...Array.from(chatMap)]);\n      }\n    });\n  };\n\n  ...\n\n}\n`)),mdx(NextBlock,{steps:[{text:\"Push Notifications\",link:\"/getting-started/push-notifications\"}],mdxType:\"NextBlock\"}))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"getting-started/listing-chats","lastUpdatedOn":"2022-08-23T21:43:23+09:00"}},"__N_SSG":true}