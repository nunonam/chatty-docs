{"pageProps":{"frontmatter":{},"headings":[{"depth":2,"value":"1. How to connect to chatlist socket."},{"depth":2,"value":"2. How to fetch chatlist"},{"depth":3,"value":"fetchChatList payloads"},{"depth":2,"value":"3. ChatList socket handlers"},{"depth":3,"value":"1). onChatListConnect"},{"depth":3,"value":"2). onChatListFetch"},{"depth":3,"value":"3). onChatRefresh"},{"depth":3,"value":"In cases of updating a specific chat of ChatList"},{"depth":3,"value":"4). onChatLeave"}],"body":{"compiledSource":"var l=Object.defineProperty,d=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var i=(t,e,a)=>e in t?l(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,o=(t,e)=>{for(var a in e||(e={}))n.call(e,a)&&i(t,a,e[a]);if(r)for(var a of r(e))h.call(e,a)&&i(t,a,e[a]);return t},c=(t,e)=>d(t,C(e));var p=(t,e)=>{var a={};for(var s in t)n.call(t,s)&&e.indexOf(s)<0&&(a[s]=t[s]);if(t!=null&&r)for(var s of r(t))e.indexOf(s)<0&&h.call(t,s)&&(a[s]=t[s]);return a};const makeShortcode=t=>function(a){return console.warn(\"Component \"+t+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",o({},a))},NextBlock=makeShortcode(\"NextBlock\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var s=a,{components:t}=s,e=p(s,[\"components\"]);return mdx(MDXLayout,c(o(o({},layoutProps),e),{components:t,mdxType:\"MDXLayout\"}),mdx(\"h1\",null,\"Listing Chats\"),mdx(\"h2\",null,\"1. How to connect to chatlist socket.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Should u an instance of ChattyList class to connect to chatlist socket\"),mdx(\"li\",{parentName:\"ul\"},\"When create ChattyList instance, specify 4 chatlist handlers.\")),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\nimport * as React from 'react';\nimport { View } from 'react-native';\nimport { ChattyList, ChattyTypes } from 'chatty-client';\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState(); // state for ChattyList instance that used in this screen\n  \n  ...\n\n  /**\n   * Create ChatList instance And connect\n   */\n  React.useEffect(() => {\n    const chattylist = new ChattyList({\n      filter: {\n        group: <GROUP-NAME>,  // to get chats filtered by this group name\n        MemberId: <USER-ID>   // to get chats this MemberId is included\n      },\n      onChatListConnect: onChatListConnect, // refer to below handlers section\n      onChatListFetch: onChatListFetch,     // refer to below handlers section\n      onChatRefresh: onChatRefresh,         // refer to below handlers section\n      onChatLeave: onChatLeave              // refer to below handlers section\n    });\n\n    chattylist.connect();\n    setChatty(chattylist);\n\n    // When unmount, disconnect chatlist socket\n    return () => {\n      chattylist.disconnect();\n    }\n  }, []);\n\n  return (\n    <View>\n    /* Render UI Component */\n    </View>\n  );\n}\n\n`)),mdx(\"h2\",null,\"2. How to fetch chatlist\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"When chatlist is connected successfuly, chatty client sdk fetchs chatlist. So you don't need to call fetchChatList method.\"),mdx(\"li\",{parentName:\"ul\"},\"At onChatListFetch handler, you can see the chatlist fetched.\"),mdx(\"li\",{parentName:\"ul\"},\"But if need to fetch chatlist manually, call the methods like as below.\")),mdx(\"h3\",null,\"fetchChatList payloads\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`\nexport interface FetchChatListPayloadType {\n  /**\n   * if it's true, fetch chatlist as refresh. (page === 1)\n   * if it's false, fetch chatlist as loadmore. (page > 1)\n   */\n  refresh?: boolean;\n}\n\nchattyInstance.fetchChatList({refresh: true});\n\n// to load chatlist more\nhasNext && chattyInstance.fetchChatList({refresh: false});\n\n\n`)),mdx(\"h2\",null,\"3. ChatList socket handlers\"),mdx(\"h3\",null,\"1). onChatListConnect\"),mdx(\"p\",null,\"This is called when chatlist socket is connected successfuly.\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  \n  ...\n\n  const onChatListConnect = (data: ChattyTypes.ChatListConnectResponseType) => {\n    if (data.error) {\n      console.warn('onChatListConnect error', data.error.message);\n      return;\n    }\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"2). onChatListFetch\"),mdx(\"p\",null,\"This is called when fetchChatList is success\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n\n  ...\n\n  const onChatListFetch = (data: ChattyTypes.ChatListFetchResponseType) => {\n    if (data.error) {\n      console.warn('onChatListFetch error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      chats: [\n        id: string,     // (uuid type)\n        image: string,  // (url type)\n        name: string,\n        public: boolean,\n        distinctKey: string,\n        group: string,\n        data: any,\n        lastMessage: {\n          text: string, \n          files: string[] | null, \n          type: 'TEXT' | 'FILE' | 'JSON', \n          by: 'USER' | 'ADMIN', \n          createdAt: Date,\n          translation: {\n            [key: string]: string\n          }\n        },\n        updatedAt: Date,\n        Members: [\n          id: string,\n          name: string,\n          avatar: string,   // (url type)\n          group: string,\n          data: any,\n          language: string, // (ex: \"en\")\n          country: string,  // (ex: \"US\")\n          missedCount: number,\n          permission: \"WRITE\" | \"READ\",\n          role: \"MEMBER\" | \"ADMIN\"\n        ]\n      ],\n      hasNext: false,\n      refresh: true\n    }\n    */\n\n    \n    if (data.refresh) {\n      const messagesMap = new Map(data.chats.map((e) => [e['id'], e]));\n      setChatList(messagesMap);\n    } else {\n      setChatList((oldChats) => {\n        const chatsMap = new Map(data.chats.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldChats), ...Array.from(chatsMap)]);\n      });\n    }\n\n    setHasNext(data.hasNext);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"3). onChatRefresh\"),mdx(\"p\",null,\"This is called when need to update a specific chat of ChatList in case of navigating to Chat screen through ChatList.\"),mdx(\"h3\",null,\"In cases of updating a specific chat of ChatList\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"when lastMessage updated\"),mdx(\"li\",{parentName:\"ul\"},\"when unread messages are marked as read\")),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n\n  ...\n\n  const onChatRefresh = (data: ChattyTypes.onChatRefreshResponseType) => {\n    if (data.error) {\n      console.warn('onChatRefresh error', data.error.message);\n      return;\n    }\n\n    setChatList((oldChats) => {\n      const chatMap = new Map([[data['id'], data]]);\n\n      // When lastMessage was updated, this chat should go to top of the list\n      // Delete and add to ahead of the array\n      if (data.updatedAt !== oldChats.get(data['id'])?.updatedAt) {\n        oldChats.delete(data['id']);\n        return new Map([...Array.from(chatMap), ...Array.from(oldChats)]);\n      } else {\n        return new Map([...Array.from(oldChats), ...Array.from(chatMap)]);\n      }\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"4). onChatLeave\"),mdx(\"p\",null,\"This is called when need to leave from a specific chat of ChatList by user action.\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n\n  ...\n\n  const onChatLeave = (data: ChattyTypes.onChatLeaveResponseType) => {\n    if (data.error) {\n      console.warn('onChatLeave error', data.error.message);\n      return;\n    }\n\n    setChats((oldChats) => {\n      oldChats.delete(data.chat?.id);\n      return new Map([...Array.from(oldChats)]);\n    });\n  }\n\n  ...\n\n}\n`)),mdx(NextBlock,{steps:[{text:\"Push Notifications\",link:\"/getting-started/push-notifications\"}],mdxType:\"NextBlock\"}))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"getting-started/listing-chats.ko","lastUpdatedOn":"2023-01-28T12:03:20+09:00"}},"__N_SSG":true}