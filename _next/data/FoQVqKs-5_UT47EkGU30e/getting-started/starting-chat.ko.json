{"pageProps":{"frontmatter":{},"headings":[{"depth":2,"value":"1. 채팅을 시작하는 두가지 방법"},{"depth":3,"value":"1). 멤버 id 를 지정하여 시작하기"},{"depth":3,"value":"2). 채팅 id 를 지정하여 시작하기"},{"depth":2,"value":"2. 소켓에 연결하는 방법"},{"depth":3,"value":"ConnectChatPayloadType"},{"depth":2,"value":"3. 메세지를 가져오는 방법"},{"depth":3,"value":"fetchMessages method"},{"depth":2,"value":"4. 소켓 handlers"},{"depth":3,"value":"1). onChatConnect"},{"depth":3,"value":"2). onChatRefresh"},{"depth":3,"value":"3). onChatLeave"},{"depth":3,"value":"4). onMessagesFetch"},{"depth":3,"value":"5). onMessageReceive"},{"depth":3,"value":"6). onMessagesUpdate"},{"depth":3,"value":"7). onMessageSend"},{"depth":2,"value":"5. Send text or file message"}],"body":{"compiledSource":"var d=Object.defineProperty,g=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var p=(e,t,a)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,s=(e,t)=>{for(var a in t||(t={}))o.call(t,a)&&p(e,a,t[a]);if(r)for(var a of r(t))c.call(t,a)&&p(e,a,t[a]);return e},h=(e,t)=>g(e,l(t));var i=(e,t)=>{var a={};for(var n in e)o.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&r)for(var n of r(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a};const makeShortcode=e=>function(a){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",s({},a))},InfoBlock=makeShortcode(\"InfoBlock\"),NextBlock=makeShortcode(\"NextBlock\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,t=i(n,[\"components\"]);return mdx(MDXLayout,h(s(s({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h1\",null,\"Starting Chat\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uBA54\\uC138\\uC9C0\\uB97C \\uC8FC\\uACE0 \\uBC1B\\uB294 \\uC77C\\uBC18\\uC801\\uC778 \\uCC44\\uD305\\uD654\\uBA74\\uC744 \\uAD6C\\uD604\\uD558\\uB294 \\uBC29\\uBC95\\uC5D0 \\uAD00\\uD55C \\uBB38\\uC11C\\uC785\\uB2C8\\uB2E4. \"),mdx(\"li\",{parentName:\"ul\"},\"cloud\\uC640 socket\\uC73C\\uB85C \\uC5F0\\uACB0\\uB418\\uC5B4 \\uB3D9\\uC791\\uD569\\uB2C8\\uB2E4. \"),mdx(\"li\",{parentName:\"ul\"},\"\\uC544\\uB798 \\uC608\\uC81C\\uC758 code\\uB4E4\\uC740 Chat.tsx \\uB77C\\uACE0 \\uD558\\uB294 react native \\uD654\\uBA74\\uC758 \\uC77C\\uBD80\\uC785\\uB2C8\\uB2E4. \")),mdx(\"h2\",null,\"1. \\uCC44\\uD305\\uC744 \\uC2DC\\uC791\\uD558\\uB294 \\uB450\\uAC00\\uC9C0 \\uBC29\\uBC95\"),mdx(\"h3\",null,\"1). \\uBA64\\uBC84 id \\uB97C \\uC9C0\\uC815\\uD558\\uC5EC \\uC2DC\\uC791\\uD558\\uAE30\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uC5B4\\uB5A4 \\uBA64\\uBC84\\uC758 id\\uB9CC \\uC54C\\uACE0 \\uC788\\uB294\\uACBD\\uC6B0 member id \\uB97C \\uD1B5\\uD574 \\uC0C8\\uB85C\\uC6B4 \\uCC44\\uD305\\uC744 \\uC2DC\\uC791\\uD558\\uAC70\\uB098 \\uB610\\uB294 \\uAE30\\uC874\\uC758 \\uCC44\\uD305\\uC744 \\uC774\\uC5B4 \\uD560\\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},'\\uC774\\uB54C connect \\uBA54\\uC18C\\uB4DC\\uC758 \"with\" \\uB77C\\uB294 parameter\\uC5D0 MemberId\\uB97C \\uD560\\uB2F9\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.')),mdx(\"h3\",null,\"2). \\uCC44\\uD305 id \\uB97C \\uC9C0\\uC815\\uD558\\uC5EC \\uC2DC\\uC791\\uD558\\uAE30\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uCC44\\uD305\\uBAA9\\uB85D\\uC5D0\\uC11C \\uD2B9\\uC815 \\uCC44\\uD305\\uC744 \\uC120\\uD0DD\\uD558\\uC5EC \\uCC44\\uD305\\uC744 \\uC774\\uC5B4 \\uD558\\uB294 \\uBC29\\uBC95\\uC774 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},'\\uC774\\uB54C connect \\uBA54\\uC18C\\uB4DC\\uC758 \"at\" \\uC774\\uB77C\\uB294 parameter\\uC5D0 ChatId\\uB97C \\uD560\\uB2F9\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.')),mdx(\"h2\",null,\"2. \\uC18C\\uCF13\\uC5D0 \\uC5F0\\uACB0\\uD558\\uB294 \\uBC29\\uBC95\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uC18C\\uCF13\\uC5D0 \\uC5F0\\uACB0\\uD558\\uAE30 \\uC704\\uD574\\uC11C\\uB294 ChattyChat \\uD074\\uB798\\uC2A4\\uC758 \\uC778\\uC2A4\\uD134\\uC2A4\\uB97C \\uC0AC\\uC6A9\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},\"ChattyChat \\uD074\\uB798\\uC2A4\\uC758 \\uC778\\uC2A4\\uD134\\uC2A4\\uB97C \\uC0DD\\uC131\\uD560\\uB54C \\uC0DD\\uC131\\uC790\\uC5D0 7\\uAC1C\\uC758 chat handler\\uB97C \\uC9C0\\uC815\\uD574\\uC57C\\uD569\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},\"ChattyChat \\uD074\\uB798\\uC2A4\\uC758 \\uC0DD\\uC131\\uC790\\uC911 chattyList \\uB294 \\uC120\\uD0DD\\uC0AC\\uD56D\\uC73C\\uB85C ChattyList\\uC758 \\uC778\\uC2A4\\uD134\\uC2A4\\uC785\\uB2C8\\uB2E4. \\uCC44\\uD305\\uD654\\uBA74\\uC5D0\\uC11C \\uBCC0\\uACBD\\uB41C \\uC0C1\\uD0DC\\uAC00 \\uCC44\\uD305\\uBAA9\\uB85D\\uC5D0\\uC11C\\uB3C4 \\uC790\\uB3D9\\uC801\\uC73C\\uB85C \\uBC18\\uC601\\uC774 \\uB418\\uB3C4\\uB85D\\uD558\\uAE30 \\uC704\\uD574\\uC11C \\uD544\\uC694\\uD569\\uB2C8\\uB2E4. (\\uC608\\uB97C\\uB4E4\\uC5B4 \\uCC44\\uD305\\uBAA9\\uB85D\\uC5D0\\uC11C\\uC758 missed count\\uB97C \\uC5C5\\uB370\\uC774\\uD2B8\\uD55C\\uB2E4\\uAC70\\uB098 last message\\uB97C \\uC5C5\\uB370\\uC774\\uD2B8\\uD558\\uB294\\uACBD\\uC6B0\\uC5D0 \\uD574\\uB2F9\\uB429\\uB2C8\\uB2E4)\")),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\nimport * as React from 'react';\nimport { View } from 'react-native';\nimport Chatty, { ChattyChat, ChattyTypes } from 'chatty-client';\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState(); // state for ChattyChat instance that used in this screen\n\n  ...\n\n  React.useEffect(() => {\n    const chattychat = new ChattyChat({\n      chattyList: props.chattylist,       // Instance of ChattyList. It will help to update this chat of chatlist (In case of navigating from ChatList)\n      onChatConnect: onChatConnect,       // refer to below handlers section\n      onChatRefresh: onChatRefresh,       // refer to below handlers section\n      onChatLeave: onChatLeave,           // refer to below handlers section\n      onMessagesFetch: onMessagesFetch,   // refer to below handlers section\n      onMessageReceive: onMessageReceive, // refer to below handlers section\n      onMessagesUpdate: onMessagesUpdate, // refer to below handlers section\n      onMessageSend: onMessageSend,       // refer to below handlers section\n    });\n\n    chattychat.connect({\n      at: props.at,\n      with: props.with,\n      distinctKey: props.distinctKey,\n      group: props.group,\n      name: props.name,\n      image: props.image,\n      data: props.data\n    });\n\n    setChatty(chattychat);\n    \n    // When unmount, disconnect chatlist socket\n    return () => {\n      Chatty.getMissedCount();\n      chattychat.disconnect();\n    }\n  }, []);\n\n  return (\n    <View>\n    /* Render UI Component */\n    </View>\n  );\n\n}\n\n\n`)),mdx(\"h3\",null,\"ConnectChatPayloadType\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`export interface ConnectChatPayloadType {\n  /**\n   * Required in case of navigating from ChatList\n   * It should be a chat id\n   */\n  at?: string;\n\n  /**\n   * Required in case of starting chat by selecting member id not chat id\n   * It shoud be an array of member ids\n   */\n  with?: Array<string>;\n\n  /**\n   * This key makes the chat unique\n   * When trying to connect with a same distinctKey. always same chat is connected.\n   * Whereas, if connect without distinctKey, always new chat is created.\n   * Create your own custom key or use generateDistinctKey, static method of Chatty class which returns md5 hashed value. \n   * If using generateDistinctKey method, use member ids as parameters\n   */\n  distinctKey?: string;\n\n  /**\n   * Group name for grouping(filtering) chat at chatlist\n   * Used only when creating a new chat\n   */\n  group?: string;\n\n  /**\n   * Chat name\n   * Used only when creating a new chat\n   */\n  name?: string;\n\n  /**\n   * Image uri for chat image\n   * Used only when creating a new chat\n   */\n  image?: string;\n\n  /**\n   * Extra custom information for chat\n   * Size can't exceed 2K\n   * Used only when creating a new chat\n   */\n  data?: any;\n}\n`)),mdx(InfoBlock,{type:\"note\",mdxType:\"InfoBlock\"},\"- \\uCC44\\uD305\\uC758 \\uBA64\\uBC84\\uB294 \\uCD5C\\uB300 30\\uBA85\\uAE4C\\uC9C0 \\uB3D9\\uC2DC\\uC5D0 \\uCC38\\uC5EC\\uD560\\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"),mdx(\"h2\",null,\"3. \\uBA54\\uC138\\uC9C0\\uB97C \\uAC00\\uC838\\uC624\\uB294 \\uBC29\\uBC95\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uC18C\\uCF13\\uC774 \\uC5F0\\uACB0\\uC774 \\uB418\\uBA74, sdk \\uAC00 \\uC790\\uB3D9\\uC73C\\uB85C \\uBA54\\uC138\\uC9C0\\uB4E4\\uC744 \\uAC00\\uC838\\uC635\\uB2C8\\uB2E4. \\uB530\\uB77C\\uC11C fetchMessages method\\uB97C \\uD638\\uCD9C\\uD560 \\uD544\\uC694\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4. \"),mdx(\"li\",{parentName:\"ul\"},\"onMessagesFetch handler \\uC5D0\\uC11C fetch\\uB41C \\uBA54\\uC138\\uC9C0\\uB4E4\\uC744 \\uBCFC\\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},\"\\uB9CC\\uC57D fetchMessages \\uB97C \\uC9C1\\uC811\\uC0AC\\uC6A9\\uD558\\uC5EC \\uD638\\uCD9C\\uD558\\uACE0\\uC790 \\uD560\\uB54C\\uB294 \\uC544\\uB798\\uC640 \\uAC19\\uC774 \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4. (\\uC608: \\uBA54\\uC138\\uC9C0 \\uB354\\uBCF4\\uAE30 \\uC704\\uD574 \\uC0AC\\uC6A9\\uD558\\uB294 \\uACBD\\uC6B0)\")),mdx(\"h3\",null,\"fetchMessages method\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`export interface FetchMessagesPayloadType {\n  /**\n   * if it's true, fetch messages as refresh. (page === 1)\n   * if it's false, fetch messages as loadmore. (page > 1)\n   */\n  refresh: boolean;\n}\n\nchattyInstance.fetchMessages({refresh: true});\n\n// to load messages more\nhasNext && chattyInstance.fetchMessages({refresh: false});\n\n`)),mdx(\"h2\",null,\"4. \\uC18C\\uCF13 handlers\"),mdx(\"h3\",null,\"1). onChatConnect\"),mdx(\"p\",null,\"This is called when chat socket is connected successfuly.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  \n  ...\n\n  const onChatConnect = (data: ChattyTypes.onChatConnectResponseType) => {\n    if (data.error) {\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      id: string,     // (uuid type)\n      image: string,  // (url type)\n      name: string,\n      public: boolean,\n      distinctKey: string,\n      group: string,\n      data: any,\n      lastMessage: {\n        text: string, \n        files: string[], \n        type: 'TEXT' | 'FILE' | 'JSON', \n        by: 'USER' | 'ADMIN', \n        createdAt: Date,\n        translation: {\n          [key: string]: string\n        }\n      },\n      updatedAt: Date,\n      Members: [\n        id: string,\n        name: string,\n        avatar: string,   // (url type)\n        group: string,\n        data: any,\n        language: string, // (ex: \"en\")\n        country: string,  // (ex: \"US\")\n        missedCount: number,\n        permission: \"WRITE\" | \"READ\",\n        role: \"MEMBER\" | \"ADMIN\"\n      ]\n    }\n    */\n\n    setChat(data);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"2). onChatRefresh\"),mdx(\"p\",null,\"Callback function called when chat is refreshed. mainly called when chat member changed\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onChatRefresh = (data: ChattyTypes.onChatRefreshResponseType) => {\n    if (data.error) {\n      return;\n    }\n  \n    setChat(data);\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"3). onChatLeave\"),mdx(\"p\",null,\"Callback function called when a member of the chat was left.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onChatLeave = (data: ChattyTypes.onChatLeaveResponseType) => {\n    if (data.error) {\n      return;\n    }\n    setChat(data.chat);\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"4). onMessagesFetch\"),mdx(\"p\",null,\"Callback function called after fetching messages\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessagesFetch = (data: ChattyTypes.onMessagesFetchResponseType) => {\n    if (data.error) {\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      hasNext: true,\n      refresh: true,\n      messages: [\n        id: string,\n        text: string,\n        files: string[] | null,\n        json: any\n        type: 'TEXT' | 'FILE' | 'JSON', \n        by: 'USER' | 'ADMIN', \n        createdAt: Date,\n        readReceipt: number,\n        translation: {\n          [key: string]: string\n        },\n        Sender: {\n          id: string, \n          name: string, \n          avatar: string, \n          group: string, \n          data: any\n        }\n      ]\n    }\n    */\n    if (data.refresh) {\n      const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n      setMessages(messagesMap);\n    } else {\n      setMessages((oldMessages) => {\n        const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n      });\n    }\n\n    setHasNext(data.hasNext);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"5). onMessageReceive\"),mdx(\"p\",null,\"Callback function called when receive new message.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  /**\n    * Response data type.\n  data: {\n    id: string,\n    text: string,\n    files: string[] | null,\n    json: any\n    type: 'TEXT' | 'FILE' | 'JSON', \n    by: 'USER' | 'ADMIN', \n    createdAt: Date,\n    readReceipt: number,\n    translation: {\n      [key: string]: string\n    },\n    Sender: {\n      id: string, \n      name: string, \n      avatar: string, \n      group: string, \n      data: any\n    }\n  }\n  */\n  const onMessageReceive = (data: ChattyTypes.onMessageReceiveResponseType) => {\n    if (data.error) {\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[data['id'], data]]);\n      return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"6). onMessagesUpdate\"),mdx(\"p\",null,\"Callback function called when messages are updated. mainly used when readReceipt updated.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessagesUpdate = (data: ChattyTypes.onMessagesUpdateResponseType) => {\n    if (data.error) {\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messagesMap = new Map(data.map((e) => [e['id'], e]));\n      return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"7). onMessageSend\"),mdx(\"p\",null,\"Callback function called after message is sent\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessageSend = (data: ChattyTypes.onMessageSendResponseType) => {\n    if (data.error) {\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[data['id'], data]]);\n      return new Map([...Array.from(oldMessages), ...Array.from(messageMap)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h2\",null,\"5. Send text or file message\"),mdx(\"p\",null,`The result of sending message can be confirmed in onMessageSend handlers.\nsendTextMessage and sendFileMessage methods returns a temporary message syncronously.`),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const sendTextMessage = (message: string) => {\n    const newMessage = chatty?.sendTextMessage(message);\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendTextMessage fail');\n    }\n  }\n\n  const sendFileMessage = (message: Array<ChattyTypes.FileType>) => {\n    const newMessage = chatty?.sendFileMessage(message);\n\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendFileMessage fail');\n    }\n  }\n\n  ...\n\n}\n`)),mdx(NextBlock,{steps:[{text:\"Listing Chats\",link:\"/getting-started/listing-chats.ko\"}],mdxType:\"NextBlock\"}))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"getting-started/starting-chat.ko","lastUpdatedOn":"2023-02-28T21:01:13+09:00"}},"__N_SSG":true}