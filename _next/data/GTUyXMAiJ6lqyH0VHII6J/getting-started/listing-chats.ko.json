{"pageProps":{"frontmatter":{},"headings":[{"depth":2,"value":"1. 소켓에 연결하는 방법"},{"depth":2,"value":"2. 채팅목록을 가져오는 방법"},{"depth":3,"value":"fetchChatList payloads"},{"depth":2,"value":"3. 소켓 handlers"},{"depth":3,"value":"1). onChatListConnect"},{"depth":3,"value":"2). onChatListFetch"},{"depth":3,"value":"3). onChatRefresh"},{"depth":3,"value":"In cases of updating a specific chat of ChatList"},{"depth":3,"value":"4). onChatLeave"}],"body":{"compiledSource":"var l=Object.defineProperty,d=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var i=(t,e,a)=>e in t?l(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,r=(t,e)=>{for(var a in e||(e={}))n.call(e,a)&&i(t,a,e[a]);if(o)for(var a of o(e))h.call(e,a)&&i(t,a,e[a]);return t},c=(t,e)=>d(t,C(e));var p=(t,e)=>{var a={};for(var s in t)n.call(t,s)&&e.indexOf(s)<0&&(a[s]=t[s]);if(t!=null&&o)for(var s of o(t))e.indexOf(s)<0&&h.call(t,s)&&(a[s]=t[s]);return a};const makeShortcode=t=>function(a){return console.warn(\"Component \"+t+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",r({},a))},NextBlock=makeShortcode(\"NextBlock\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var s=a,{components:t}=s,e=p(s,[\"components\"]);return mdx(MDXLayout,c(r(r({},layoutProps),e),{components:t,mdxType:\"MDXLayout\"}),mdx(\"h1\",null,\"Listing Chats\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uC77C\\uBC18\\uC801\\uC778 \\uCC44\\uD305\\uBAA9\\uB85D \\uD654\\uBA74\\uC744 \\uAD6C\\uD604\\uD558\\uB294 \\uBC29\\uBC95\\uC5D0 \\uAD00\\uD55C \\uBB38\\uC11C\\uC785\\uB2C8\\uB2E4. \"),mdx(\"li\",{parentName:\"ul\"},\"cloud\\uC640 socket\\uC73C\\uB85C \\uC5F0\\uACB0\\uB418\\uC5B4 \\uB3D9\\uC791\\uD569\\uB2C8\\uB2E4. \"),mdx(\"li\",{parentName:\"ul\"},\"\\uC544\\uB798 \\uC608\\uC81C\\uC758 code\\uB4E4\\uC740 ChatList.tsx \\uB77C\\uACE0 \\uD558\\uB294 react native \\uD654\\uBA74\\uC758 \\uC77C\\uBD80\\uC785\\uB2C8\\uB2E4. \")),mdx(\"h2\",null,\"1. \\uC18C\\uCF13\\uC5D0 \\uC5F0\\uACB0\\uD558\\uB294 \\uBC29\\uBC95\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uC18C\\uCF13\\uC5D0 \\uC5F0\\uACB0\\uD558\\uAE30 \\uC704\\uD574\\uC11C\\uB294 ChattyList \\uD074\\uB798\\uC2A4\\uC758 \\uC778\\uC2A4\\uD134\\uC2A4\\uB97C \\uC0AC\\uC6A9\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},\"ChattyList \\uD074\\uB798\\uC2A4\\uC758 \\uC778\\uC2A4\\uD134\\uC2A4\\uB97C \\uC0DD\\uC131\\uD560\\uB54C \\uC0DD\\uC131\\uC790\\uC5D0 4\\uAC1C\\uC758 chatlist handler\\uB97C \\uC9C0\\uC815\\uD574\\uC57C\\uD569\\uB2C8\\uB2E4.\")),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\nimport * as React from 'react';\nimport { View } from 'react-native';\nimport { ChattyList, ChattyTypes } from 'chatty-client';\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState(); // state for ChattyList instance that used in this screen\n  \n  ...\n\n  /**\n   * Create ChatList instance And connect\n   */\n  React.useEffect(() => {\n    const chattylist = new ChattyList({\n      filter: {\n        group: <GROUP-NAME>,  // to get chats filtered by this group name\n        MemberId: <USER-ID>   // to get chats this MemberId is included\n      },\n      onChatListConnect: onChatListConnect, // refer to below handlers section\n      onChatListFetch: onChatListFetch,     // refer to below handlers section\n      onChatRefresh: onChatRefresh,         // refer to below handlers section\n      onChatLeave: onChatLeave              // refer to below handlers section\n    });\n\n    chattylist.connect();\n    setChatty(chattylist);\n\n    // When unmount, disconnect chatlist socket\n    return () => {\n      chattylist.disconnect();\n    }\n  }, []);\n\n  return (\n    <View>\n    /* Render UI Component */\n    </View>\n  );\n}\n\n`)),mdx(\"h2\",null,\"2. \\uCC44\\uD305\\uBAA9\\uB85D\\uC744 \\uAC00\\uC838\\uC624\\uB294 \\uBC29\\uBC95\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"\\uC18C\\uCF13\\uC774 \\uC5F0\\uACB0\\uC774 \\uB418\\uBA74, sdk \\uAC00 \\uC790\\uB3D9\\uC73C\\uB85C \\uCC44\\uD305\\uBAA9\\uB85D\\uC744 \\uAC00\\uC838\\uC635\\uB2C8\\uB2E4. \\uB530\\uB77C\\uC11C fetchChatList method\\uB97C \\uD638\\uCD9C\\uD560 \\uD544\\uC694\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4. \"),mdx(\"li\",{parentName:\"ul\"},\"onChatListFetch handler \\uC5D0\\uC11C fetch\\uB41C \\uBAA9\\uB85D\\uB4E4\\uC744 \\uBCFC\\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"),mdx(\"li\",{parentName:\"ul\"},\"\\uB9CC\\uC57D fetchChatList \\uB97C \\uC9C1\\uC811\\uC0AC\\uC6A9\\uD558\\uC5EC \\uD638\\uCD9C\\uD558\\uACE0\\uC790 \\uD560\\uB54C\\uB294 \\uC544\\uB798\\uC640 \\uAC19\\uC774 \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4. (\\uC608: \\uCC44\\uD305\\uBAA9\\uB85D \\uB354\\uBCF4\\uAE30 \\uC704\\uD574 \\uC0AC\\uC6A9\\uD558\\uB294 \\uACBD\\uC6B0)\")),mdx(\"h3\",null,\"fetchChatList payloads\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`\nexport interface FetchChatListPayloadType {\n  /**\n   * if it's true, fetch chatlist as refresh. (page === 1)\n   * if it's false, fetch chatlist as loadmore. (page > 1)\n   */\n  refresh?: boolean;\n}\n\nchattyInstance.fetchChatList({refresh: true});\n\n// to load chatlist more\nhasNext && chattyInstance.fetchChatList({refresh: false});\n\n\n`)),mdx(\"h2\",null,\"3. \\uC18C\\uCF13 handlers\"),mdx(\"h3\",null,\"1). onChatListConnect\"),mdx(\"p\",null,\"This is called when chatlist socket is connected successfuly.\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  \n  ...\n\n  const onChatListConnect = (data: ChattyTypes.ChatListConnectResponseType) => {\n    if (data.error) {\n      console.warn('onChatListConnect error', data.error.message);\n      return;\n    }\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"2). onChatListFetch\"),mdx(\"p\",null,\"This is called when fetchChatList is success\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chatlist, setChatList] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n\n  ...\n\n  const onChatListFetch = (data: ChattyTypes.ChatListFetchResponseType) => {\n    if (data.error) {\n      console.warn('onChatListFetch error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      chats: [\n        id: string,     // (uuid type)\n        image: string,  // (url type)\n        name: string,\n        public: boolean,\n        distinctKey: string,\n        group: string,\n        data: any,\n        lastMessage: {\n          text: string, \n          files: string[] | null, \n          type: 'TEXT' | 'FILE' | 'JSON', \n          by: 'USER' | 'ADMIN', \n          createdAt: Date,\n          translation: {\n            [key: string]: string\n          }\n        },\n        updatedAt: Date,\n        Members: [\n          id: string,\n          name: string,\n          avatar: string,   // (url type)\n          group: string,\n          data: any,\n          language: string, // (ex: \"en\")\n          country: string,  // (ex: \"US\")\n          missedCount: number,\n          permission: \"WRITE\" | \"READ\",\n          role: \"MEMBER\" | \"ADMIN\"\n        ]\n      ],\n      hasNext: false,\n      refresh: true\n    }\n    */\n\n    \n    if (data.refresh) {\n      const messagesMap = new Map(data.chats.map((e) => [e['id'], e]));\n      setChatList(messagesMap);\n    } else {\n      setChatList((oldChats) => {\n        const chatsMap = new Map(data.chats.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldChats), ...Array.from(chatsMap)]);\n      });\n    }\n\n    setHasNext(data.hasNext);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"3). onChatRefresh\"),mdx(\"p\",null,\"This is called when need to update a specific chat of ChatList in case of navigating to Chat screen through ChatList.\"),mdx(\"h3\",null,\"In cases of updating a specific chat of ChatList\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"when lastMessage updated\"),mdx(\"li\",{parentName:\"ul\"},\"when unread messages are marked as read\")),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n\n  ...\n\n  const onChatRefresh = (data: ChattyTypes.onChatRefreshResponseType) => {\n    if (data.error) {\n      console.warn('onChatRefresh error', data.error.message);\n      return;\n    }\n\n    setChatList((oldChats) => {\n      const chatMap = new Map([[data['id'], data]]);\n\n      // When lastMessage was updated, this chat should go to top of the list\n      // Delete and add to ahead of the array\n      if (data.updatedAt !== oldChats.get(data['id'])?.updatedAt) {\n        oldChats.delete(data['id']);\n        return new Map([...Array.from(chatMap), ...Array.from(oldChats)]);\n      } else {\n        return new Map([...Array.from(oldChats), ...Array.from(chatMap)]);\n      }\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"4). onChatLeave\"),mdx(\"p\",null,\"This is called when need to leave from a specific chat of ChatList by user action.\"),mdx(\"p\",null,\"Below code is a part of ChatList.tsx\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`ChatList.tsx\n\n...\n\nconst ChatList = (props: ChatListProps) => {\n\n  ...\n\n  const onChatLeave = (data: ChattyTypes.onChatLeaveResponseType) => {\n    if (data.error) {\n      console.warn('onChatLeave error', data.error.message);\n      return;\n    }\n\n    setChats((oldChats) => {\n      oldChats.delete(data.chat?.id);\n      return new Map([...Array.from(oldChats)]);\n    });\n  }\n\n  ...\n\n}\n`)),mdx(NextBlock,{steps:[{text:\"Push Notifications\",link:\"/getting-started/push-notifications.ko\"}],mdxType:\"NextBlock\"}))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"getting-started/listing-chats.ko","lastUpdatedOn":"2023-01-30T21:54:29+09:00"}},"__N_SSG":true}