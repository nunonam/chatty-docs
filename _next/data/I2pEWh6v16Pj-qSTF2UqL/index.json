{"pageProps":{"frontmatter":{"title":"Make your service chatty !","subtitle":"Use frontend sdk for javascript and cloud server as a service for socket communications"},"headings":[{"depth":2,"value":"Introduction"},{"depth":2,"value":"Features"},{"depth":2,"value":"Installation"},{"depth":2,"value":"Initialize"},{"depth":2,"value":"Start chat with peer member id"}],"body":{"compiledSource":"var h=Object.defineProperty,d=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(e,a,s)=>a in e?h(e,a,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[a]=s,r=(e,a)=>{for(var s in a||(a={}))o.call(a,s)&&c(e,s,a[s]);if(n)for(var s of n(a))i.call(a,s)&&c(e,s,a[s]);return e},l=(e,a)=>d(e,m(a));var p=(e,a)=>{var s={};for(var t in e)o.call(e,t)&&a.indexOf(t)<0&&(s[t]=e[t]);if(e!=null&&n)for(var t of n(e))a.indexOf(t)<0&&i.call(e,t)&&(s[t]=e[t]);return s};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(s){var t=s,{components:e}=t,a=p(t,[\"components\"]);return mdx(MDXLayout,l(r(r({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"Introduction\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Easy & Fast solution to integrate chat service to your application \"),mdx(\"li\",{parentName:\"ul\"},\"Just use javascript(typescript also) sdk provided by \",mdx(\"strong\",null,\"chatty-client\"),\" npm package and then chat data are managed automatically at the cloud server\"),mdx(\"li\",{parentName:\"ul\"},\"Start with free and then experience chat implementation on your app in several hours\")),mdx(\"h2\",null,\"Features\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Peer to Peer Chat\"),mdx(\"li\",{parentName:\"ul\"},\"Listing Chats\"),mdx(\"li\",{parentName:\"ul\"},\"Push Notifications\"),mdx(\"li\",{parentName:\"ul\"},\"Group Chat\"),mdx(\"li\",{parentName:\"ul\"},\"Image Upload\"),mdx(\"li\",{parentName:\"ul\"},\"Auto Translation\"),mdx(\"li\",{parentName:\"ul\"},\"Missed Message Count\")),mdx(\"h2\",null,\"Installation\"),mdx(\"p\",null,\"with npm\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-npm\"}),`npm install chatty-client\n`)),mdx(\"p\",null,\"with yarn\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-yarn\"}),`yarn add chatty-client\n`)),mdx(\"h2\",null,\"Initialize\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"To use chat, first of all, your apiKey to verify members who uses a chat should be registered.\"),mdx(\"li\",{parentName:\"ul\"},\"A member of chatty chat means user who uses a chat in your service. \"),mdx(\"li\",{parentName:\"ul\"},\"'id' and 'name' of member should be specified.\"),mdx(\"li\",{parentName:\"ul\"},\"'deviceToken' should be return value of getToken function of firebase and is used for push notification of receiving chat messages\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-javascript\"}),`\nimport Chatty from 'chatty-client';\n\n\n/*\n When identifier of user is specific, call init function\n Ex) \n 1. during application bootup process, \n 2. after new user join or login\n */\n\ntry {\n  await Chatty.init({\n    apiKey: CHATTY_API_KEY,     // API Key of your app that created in dashboard \n    member: {\n      id: user.id,              // mandatory\n      name: user.name,          // mandatory\n      avatar: user.avatar,      // optional (url type started with 'https://')  \n      deviceToken: 'xxxxxxxxxx' // optional \n      language: 'en'            // optional\n      country: 'US'             // optional\n    },\n  })\n} catch (err) {\n  console.error('chatInit error', err);\n}\n\n`)),mdx(\"h2\",null,\"Start chat with peer member id\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Step of connecting and start chat\",mdx(\"blockquote\",{parentName:\"li\"},mdx(\"ol\",{parentName:\"blockquote\"},mdx(\"li\",{parentName:\"ol\"},\"register callback function for chatty event\"),mdx(\"li\",{parentName:\"ol\"},\"call connectChat method\"),mdx(\"li\",{parentName:\"ol\"},\"call fetchMessages method\"),mdx(\"li\",{parentName:\"ol\"},\"send text or file message\")))),mdx(\"li\",{parentName:\"ul\"},\"below example is in case of starting with peer member id\")),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{className:\"language-typescript\"}),`\nimport Chatty from 'chatty-client';\n\n...\n\nconst ChattyChat = (props) => {\n  \n  ...\n\n  /**\n   * @description define callback function called after chat is connected\n   * @param chat chat data when chat connection is success\n   * @param error error data when chat connection is failed\n   * @returns \n   */\n  const onChatConnect = (chat: ChattyTypes.ChatConnectResponseType, error: ChattyTypes.ErrorResponseType) => {\n    if (error || !chat) {\n      console.warn('onChatConnect error', error);\n      setPullToRefresh(false);\n      return;\n    }\n\n    setChat(chat);\n    setConnected(true);\n  };\n\n  /**\n   * @description define callback function called after fetching recent messages, it is called after fetchMessages method of Chatty class\n   * @param data recent messages when fetching messages is success\n   * @param error error data when fetching messages is failed\n   * @returns \n   */\n  const onMessagesFetch = (data: ChattyTypes.MessagesFetchResponseType, error: ChattyTypes.ErrorResponseType) => {\n    if (error || !data) {\n      console.warn('onMessagesFetch error', error);\n      return;\n    }\n    if (data.refresh) {\n      const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n      setMessages(messagesMap);\n      setHasNext(data.hasNext);\n      setPullToRefresh(false);\n    } else {\n      setMessages((oldMessages) => {\n        const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n      });\n      setHasNext(data.hasNext);\n    }\n    // setLoading(false);\n  };\n\n  /**\n   * @description define callback function called when receive UPDATE_MESSAGES event. mainly updated message status i.e readReceipt\n   * @param messages messages updated when success\n   * @param error error data when failed\n   * @returns \n   */\n  const onMessagesUpdate = (messages: ChattyTypes.MessagesUpdateResponseType, error: ChattyTypes.ErrorResponseType) => {\n    if (error || !messages) {\n      console.warn('onMessagesUpdate error', error);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messagesMap = new Map(messages.map((e) => [e['id'], e]));\n      return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n    });\n\n  };\n\n  /**\n   * @description define callback function called when receive new message (NEW_MESSAGE event)\n   * @param message message when receving message is success\n   * @param error error data when failed\n   * @returns \n   */\n  const onMessageReceive = (message: ChattyTypes.MessageReceiveResponseType, error: ChattyTypes.ErrorResponseType) => {\n    if (error || !message) {\n      console.warn('onMessageReceive error', error);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[message['id'], message]]);\n      return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n    });\n  };\n\n  /**\n   * @description define callback function called when send message (SEND_MESSAGE event)\n   * @param message message when sending message is success \n   * @param error  error data when failed\n   * @returns \n   */\n  const onMessageSend = (message: ChattyTypes.MessageSendResponseType, error: ChattyTypes.ErrorResponseType) => {\n    if (error || !message) {\n      console.warn('onMessageSend error', error);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[message['id'], message]]);\n      return new Map([...Array.from(oldMessages), ...Array.from(messageMap)]);\n    });\n  };\n\n  /**\n   * @description define callback function called when chat is refreshed (REFRESH_CHAT event). mainly updated when chat member changed\n   * @param chat chat data when refreshing chat is success\n   * @param error error data when failed\n   * @returns \n   */\n  const onChatRefresh = (chat: ChattyTypes.ChatRefreshResponseType, error: ChattyTypes.ErrorResponseType) => {\n    if (error || !chat) {\n      console.warn('onChatUpdate error', error);\n      return;\n    }\n    setChat(chat);\n  }\n\n  /**\n   * @description function to call sendTextMessage method when send text message\n   * @param message text mesage data\n   */\n  const sendTextMessage = (message: string) => {\n    const newMessage = chatty?.sendTextMessage(message);\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendTextMessage fail');\n    }\n  }\n\n  /**\n   * @description function to call sendFileMessage method when send file message\n   * @param message file message data\n   */\n  const sendFileMessage = (message: Array<ChattyTypes.FileType>) => {\n    const newMessage = chatty?.sendFileMessage(message);\n\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendFileMessage fail');\n    }\n  }\n\n  /**\n   * @description\n   * when chat is connected, call fetchMessages method\n   * parameter is boolean type. to refresh set to true\n   */\n  React.useEffect(() => {\n    connected && pullToRefresh && chatty?.fetchMessages(true);\n  }, [pullToRefresh, connected]);\n\n\n  /**\n   * @description\n   * Fist of all, register callback function for chatty events\n   * and then call connectChat method\n   * \n   * Payload of connectChat method\n   * at: chat id when coming from chatlist\n   * with: peer member id. use when selecing member instead of selecting chat\n   * distinctKey: this makes chat unique. it is generated automatically by sdk if undefined, specify null to allow duplicate and can assign your own value\n   * group: value for grouping chatlist \n   * name: specify chat name\n   * image: specify chat image\n   */\n  React.useEffect(() => {\n    chatty.onChatConnect(onChatConnect);\n    chatty.onMessagesFetch(onMessagesFetch);\n    chatty.onMessagesUpdate(onMessagesUpdate);\n    chatty.onMessageReceive(onMessageReceive);\n    chatty.onMessageSend(onMessageSend);\n    chatty.onChatRefresh(onChatRefresh);\n    chatty.connectChat({\n      at: props.at,\n      with: props.with,\n      distinctKey: props.distinctKey,\n      group: props.group,\n      name: props.name,\n      image: props.image\n    });\n\n    return () => {\n      chatty.disconnectChat();\n    }\n  }, []);\n\n  ...\n\n  return (\n    // render chat screen\n  );\n}\n`)),mdx(\"p\",null,\"Congratulations! You're ready to start your first chat app using ChattyCloud.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"index","lastUpdatedOn":"2022-08-09T08:02:22.873Z"}},"__N_SSG":true}