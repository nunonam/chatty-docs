{"pageProps":{"frontmatter":{},"headings":[{"depth":2,"value":"1. Two way of starting Chat"},{"depth":3,"value":"1). Start with member id"},{"depth":3,"value":"2). Start at chat id"},{"depth":2,"value":"2. How to connect to chat socket."},{"depth":3,"value":"ConnectChatPayloadType"},{"depth":2,"value":"3. How to fetch messages"},{"depth":3,"value":"fetchMessages methods"},{"depth":2,"value":"4. Chat socket handlers"},{"depth":3,"value":"1). onChatConnect"},{"depth":3,"value":"2). onChatRefresh"},{"depth":3,"value":"3). onChatLeave"},{"depth":3,"value":"4). onMessagesFetch"},{"depth":3,"value":"5). onMessageReceive"},{"depth":3,"value":"6). onMessagesUpdate"},{"depth":3,"value":"7). onMessageSend"},{"depth":2,"value":"5. Send text or file message"}],"body":{"compiledSource":"var g=Object.defineProperty,d=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var h=(e,t,a)=>t in e?g(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,s=(e,t)=>{for(var a in t||(t={}))o.call(t,a)&&h(e,a,t[a]);if(r)for(var a of r(t))c.call(t,a)&&h(e,a,t[a]);return e},i=(e,t)=>d(e,l(t));var p=(e,t)=>{var a={};for(var n in e)o.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&r)for(var n of r(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a};const makeShortcode=e=>function(a){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",s({},a))},InfoBlock=makeShortcode(\"InfoBlock\"),NextBlock=makeShortcode(\"NextBlock\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,t=p(n,[\"components\"]);return mdx(MDXLayout,i(s(s({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h1\",null,\"Starting Chat\"),mdx(\"h2\",null,\"1. Two way of starting Chat\"),mdx(\"h3\",null,\"1). Start with member id\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Used when starting chat by selecting peer member id (in case of not being aware of chat id)\"),mdx(\"li\",{parentName:\"ul\"},`Let's assume that user want to chat by touching chat button at other user's profile screen. If the other user also registered as a chat member through init method, Chating with the user is an available.\nPressing the chat button and navigating to chat screen with 'with' param that indicates member id is the begining of starting a chat.`)),mdx(\"h3\",null,\"2). Start at chat id\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Used when starting chat by selecting a chat at chatlist\"),mdx(\"li\",{parentName:\"ul\"},\"Pressing a chat of the chatlist and navigating to a chat screen with 'at' param that indicates chat id is the begining of starting a chat.\")),mdx(\"h2\",null,\"2. How to connect to chat socket.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Should use an instance of ChattyChat class to connect to chat socket\"),mdx(\"li\",{parentName:\"ul\"},\"When create ChattyChat instance, specify 7 chat handlers.\"),mdx(\"li\",{parentName:\"ul\"},\"chattyList of ChattyChat constructor is an optional parameter and an instance of ChattyList class. In case of navigating from ChatList, use the instance of chatlist then it will help to update the chat of chatlist without writing code\")),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\nimport * as React from 'react';\nimport { View } from 'react-native';\nimport Chatty, { ChattyChat, ChattyTypes } from 'chatty-client';\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState(); // state for ChattyChat instance that used in this screen\n\n  ...\n\n  React.useEffect(() => {\n    const chattychat = new ChattyChat({\n      chattyList: props.chattylist,       // Instance of ChattyList. It will help to update this chat of chatlist (In case of navigating from ChatList)\n      onChatConnect: onChatConnect,       // refer to below handlers section\n      onChatRefresh: onChatRefresh,       // refer to below handlers section\n      onChatLeave: onChatLeave,           // refer to below handlers section\n      onMessagesFetch: onMessagesFetch,   // refer to below handlers section\n      onMessageReceive: onMessageReceive, // refer to below handlers section\n      onMessagesUpdate: onMessagesUpdate, // refer to below handlers section\n      onMessageSend: onMessageSend,       // refer to below handlers section\n    });\n\n    chattychat.connect({\n      at: props.at,\n      with: props.with,\n      distinctKey: props.distinctKey,\n      group: props.group,\n      name: props.name,\n      image: props.image,\n      data: props.data\n    });\n\n    setChatty(chattychat);\n    \n    // When unmount, disconnect chatlist socket\n    return () => {\n      Chatty.getMissedCount();\n      chattychat.disconnect();\n    }\n  }, []);\n\n  return (\n    <View>\n    /* Render UI Component */\n    </View>\n  );\n\n}\n\n\n`)),mdx(\"h3\",null,\"ConnectChatPayloadType\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`export interface ConnectChatPayloadType {\n  /**\n   * Required in case of navigating from ChatList\n   * It should be a chat id\n   */\n  at?: string;\n\n  /**\n   * Required in case of starting chat by selecting member id not chat id\n   * It shoud be an array of member ids\n   */\n  with?: Array<string>;\n\n  /**\n   * This key makes the chat unique\n   * When trying to connect with a same distinctKey. always same chat is connected.\n   * Whereas, if connect without distinctKey, always new chat is created.\n   * Create your own custom key or use generateDistinctKey, static method of Chatty class which returns md5 hashed value. \n   * If using generateDistinctKey method, use member ids as parameters\n   */\n  distinctKey?: string;\n\n  /**\n   * Group name for grouping(filtering) chat at chatlist\n   * Used only when creating a new chat\n   */\n  group?: string;\n\n  /**\n   * Chat name\n   * Used only when creating a new chat\n   */\n  name?: string;\n\n  /**\n   * Image uri for chat image\n   * Used only when creating a new chat\n   */\n  image?: string;\n\n  /**\n   * Extra custom information for chat\n   * Size can't exceed 2K\n   * Used only when creating a new chat\n   */\n  data?: any;\n}\n`)),mdx(InfoBlock,{type:\"note\",mdxType:\"InfoBlock\"},\"- Chat Members can join until maximum 30\"),mdx(\"h2\",null,\"3. How to fetch messages\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"When chat is connected successfuly, chatty client sdk fetchs messages. So you don't need to call fetchMessages method.\"),mdx(\"li\",{parentName:\"ul\"},\"At onMessagesFetch handler, you can see the messages fetched.\"),mdx(\"li\",{parentName:\"ul\"},\"But if need to fetch messages manually, call the methods like as below.\")),mdx(\"h3\",null,\"fetchMessages methods\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`export interface FetchMessagesPayloadType {\n  /**\n   * if it's true, fetch messages as refresh. (page === 1)\n   * if it's false, fetch messages as loadmore. (page > 1)\n   */\n  refresh: boolean;\n}\n\nchattyInstance.fetchMessages({refresh: true});\n\n// to load messages more\nhasNext && chattyInstance.fetchMessages({refresh: false});\n\n`)),mdx(\"h2\",null,\"4. Chat socket handlers\"),mdx(\"h3\",null,\"1). onChatConnect\"),mdx(\"p\",null,\"This is called when chat socket is connected successfuly.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  \n  ...\n\n  const onChatConnect = (data: ChattyTypes.onChatConnectResponseType) => {\n    if (data.error) {\n      console.warn('onChatConnect error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      id: string,     // (uuid type)\n      image: string,  // (url type)\n      name: string,\n      public: boolean,\n      distinctKey: string,\n      group: string,\n      data: any,\n      lastMessage: {\n        text: string, \n        files: string[], \n        type: 'TEXT' | 'FILE' | 'JSON', \n        by: 'USER' | 'ADMIN', \n        createdAt: Date,\n        translation: {\n          [key: string]: string\n        }\n      },\n      updatedAt: Date,\n      Members: [\n        id: string,\n        name: string,\n        avatar: string,   // (url type)\n        group: string,\n        data: any,\n        language: string, // (ex: \"en\")\n        country: string,  // (ex: \"US\")\n        missedCount: number,\n        permission: \"WRITE\" | \"READ\",\n        role: \"MEMBER\" | \"ADMIN\"\n      ]\n    }\n    */\n\n    setChat(data);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"2). onChatRefresh\"),mdx(\"p\",null,\"Callback function called when chat is refreshed. mainly called when chat member changed\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onChatRefresh = (data: ChattyTypes.onChatRefreshResponseType) => {\n    if (data.error) {\n      console.warn('onChatRefresh error', data.error.message);\n      return;\n    }\n  \n    setChat(data);\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"3). onChatLeave\"),mdx(\"p\",null,\"Callback function called when a member of the chat was left.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onChatLeave = (data: ChattyTypes.onChatLeaveResponseType) => {\n    if (data.error) {\n      console.warn('onChatLeave error', data.error.message);\n      return;\n    }\n    setChat(data.chat);\n  }\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"4). onMessagesFetch\"),mdx(\"p\",null,\"Callback function called after fetching messages\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessagesFetch = (data: ChattyTypes.onMessagesFetchResponseType) => {\n    if (data.error) {\n      console.warn('onMessagesFetch error', data.error.message);\n      return;\n    }\n\n    /**\n     * Response data type.\n    data: {\n      hasNext: true,\n      refresh: true,\n      messages: [\n        id: string,\n        text: string,\n        files: string[] | null,\n        json: any\n        type: 'TEXT' | 'FILE' | 'JSON', \n        by: 'USER' | 'ADMIN', \n        createdAt: Date,\n        readReceipt: number,\n        translation: {\n          [key: string]: string\n        },\n        Sender: {\n          id: string, \n          name: string, \n          avatar: string, \n          group: string, \n          data: any\n        }\n      ]\n    }\n    */\n    if (data.refresh) {\n      const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n      setMessages(messagesMap);\n    } else {\n      setMessages((oldMessages) => {\n        const messagesMap = new Map(data.messages.map((e) => [e['id'], e]));\n        return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n      });\n    }\n\n    setHasNext(data.hasNext);\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"5). onMessageReceive\"),mdx(\"p\",null,\"Callback function called when receive new message.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  /**\n    * Response data type.\n  data: {\n    id: string,\n    text: string,\n    files: string[] | null,\n    json: any\n    type: 'TEXT' | 'FILE' | 'JSON', \n    by: 'USER' | 'ADMIN', \n    createdAt: Date,\n    readReceipt: number,\n    translation: {\n      [key: string]: string\n    },\n    Sender: {\n      id: string, \n      name: string, \n      avatar: string, \n      group: string, \n      data: any\n    }\n  }\n  */\n  const onMessageReceive = (data: ChattyTypes.onMessageReceiveResponseType) => {\n    if (data.error) {\n      console.warn('onMessageReceive error', data.error.message);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[data['id'], data]]);\n      return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"6). onMessagesUpdate\"),mdx(\"p\",null,\"Callback function called when messages are updated. mainly used when readReceipt updated.\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessagesUpdate = (data: ChattyTypes.onMessagesUpdateResponseType) => {\n    if (data.error) {\n      console.warn('onMessagesUpdate error', data.error.message);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messagesMap = new Map(data.map((e) => [e['id'], e]));\n      return new Map([...Array.from(oldMessages), ...Array.from(messagesMap)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h3\",null,\"7). onMessageSend\"),mdx(\"p\",null,\"Callback function called after message is sent\"),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const onMessageSend = (data: ChattyTypes.onMessageSendResponseType) => {\n    if (data.error) {\n      console.warn('onMessageSend error', data.error.message);\n      return;\n    }\n\n    setMessages((oldMessages) => {\n      const messageMap = new Map([[data['id'], data]]);\n      return new Map([...Array.from(oldMessages), ...Array.from(messageMap)]);\n    });\n  };\n\n  ...\n\n}\n`)),mdx(\"h2\",null,\"5. Send text or file message\"),mdx(\"p\",null,`The result of sending message can be confirmed in onMessageSend handlers.\nsendTextMessage and sendFileMessage methods returns a temporary message syncronously.`),mdx(\"p\",null,\"Below code is a part of Chat.tsx\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-typescript\"}),`Chat.tsx\n\n...\n\nconst Chat = (props: ChatProps) => {\n  const [chatty, setChatty] = React.useState();\n  const [chat, setChat] = React.useState();\n  const [messages, setMessages] = React.useState(new Map());\n  const [hasNext, setHasNext] = React.useState(true);\n  \n  ...\n\n  const sendTextMessage = (message: string) => {\n    const newMessage = chatty?.sendTextMessage(message);\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendTextMessage fail');\n    }\n  }\n\n  const sendFileMessage = (message: Array<ChattyTypes.FileType>) => {\n    const newMessage = chatty?.sendFileMessage(message);\n\n    if (newMessage) {\n      setMessages((oldMessages) => {\n        const messageMap = new Map([[newMessage['id'], newMessage]]);\n        return new Map([...Array.from(messageMap), ...Array.from(oldMessages)]);\n      });\n      toTop();\n    } else {\n      console.debug('sendFileMessage fail');\n    }\n  }\n\n  ...\n\n}\n`)),mdx(NextBlock,{steps:[{text:\"Listing Chats\",link:\"/getting-started/listing-chats.en\"}],mdxType:\"NextBlock\"}))}MDXContent.isMDXComponent=!0;\n","scope":{}},"fields":{"slug":"getting-started/starting-chat.en","lastUpdatedOn":"2023-01-28T14:32:00+09:00"}},"__N_SSG":true}